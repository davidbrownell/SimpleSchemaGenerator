# ----------------------------------------------------------------------
# |
# |  Errors.py
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2024-04-10 08:30:59
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2024
# |  Distributed under the MIT License.
# |
# ----------------------------------------------------------------------
"""Contains errors generated by this library"""

import textwrap

from pathlib import Path

from .Common.Error import CreateErrorType, Region

# Convenience imports
from .Common.Error import SimpleSchemaGeneratorException  # pylint: disable=unused-import


# TODO: Search for 'range' and replace with 'region'

# ----------------------------------------------------------------------
# |
# |  ANTLR Parsing Errors
# |
# ----------------------------------------------------------------------
# These errors are defined as strings rather than ErrorType because they only have a beginning
# Location and not a start and end Location as required by the Region in ErrorType.
antlr_invalid_opening_token = "Triple-quote delimiters that initiate multiline strings cannot have any content on the same line as the opening token."
antlr_invalid_closing_token = "Triple-quote delimiters that terminate multiline strings cannot have any content on the same line as the closing token."
antlr_invalid_indentation = "Invalid multiline string indentation."

ParseStructureStatementInvalidBase = CreateErrorType("Base types must be identifiers.")

ParseCreateIncludeStatementDirWithStar = CreateErrorType(
    "Filenames must be provided with wildcard imports; '{name}' is a directory.",
    name=Path,
)
ParseCreateIncludeStatementInvalidFilename = CreateErrorType(
    "'{name}' is not a valid filename.",
    name=str,
)
ParseCreateIncludeStatementInvalidDirectory = CreateErrorType(
    "'{name}' is not a valid directory.",
    name=str,
)
ParseCreateIncludeStatementInvalidWorkspace = CreateErrorType(
    "The included file '{name}' is not a descendant of any workspace.",
    name=Path,
)


# ----------------------------------------------------------------------
# |
# |  Element Construction Errors
# |
# ----------------------------------------------------------------------
CardinalityInvalidRange = CreateErrorType("Invalid cardinality ({min} > {max}).", min=int, max=int)

MetadataItemDuplicated = CreateErrorType(
    "The metadata item '{key}' was already provided at {prev_region}.",
    key=str,
    prev_region=Region,
)

TupleExpressionEmpty = CreateErrorType("No expressions were provided.")

ParseIdentifierNoChars = CreateErrorType(
    "'{id}' does not have any identifiable characters.",
    id=str,
)
ParseIdentifierNotAlpha = CreateErrorType(
    "The first identifiable character in '{id}' must be a letter or emoji.",
    id=str,
)

ParseIdentifierTypeEmpty = CreateErrorType("Identifier types must have at least one identifier.")
ParseIdentifierTypeNotType = CreateErrorType("'{id}' is not a valid type name.", id=str)

ParseIncludeStatementItemNotType = CreateErrorType(
    "The imported element '{name}' is not a type.", name=str
)
ParseIncludeStatementItemReferenceNotType = CreateErrorType(
    "'{name}' is not a type name.", name=str
)

ParseIncludeStatementInvalidFile = CreateErrorType("'{name}' is not a valid file.", name=Path)
ParseIncludeStatementInvalidItems = CreateErrorType("No items were expected.")
ParseIncludeStatementMissingItems = CreateErrorType("Items were expected.")

ParseTupleTypeMissingTypes = CreateErrorType("No tuple types were provided.")

ParseVariantTypeMissingTypes = CreateErrorType("Not enough types were provided.")
ParseVariantTypeNestedType = CreateErrorType("Nested variant types are not supported.")

RootStatementInvalidNested = CreateErrorType("Root statements cannot be nested.")


ExtensionStatementDuplicateKeywordArgError = CreateErrorType(
    "An argument for the parameter '{name}' was already provided at '{region}'.",
    name=str,
    region=Region,
)


# ----------------------------------------------------------------------
# |
# |  Type Errors
# |
# ----------------------------------------------------------------------
create_type_from_annotation_invalid_type = "'{value}' is not a supported python type."

cardinality_validate_none_not_expected = "None was not expected."
cardinality_validate_list_required = "A list of items was expected."
cardinality_validate_list_not_expected = "A list of items was not expected."
cardinality_validate_list_too_large = (
    "No more than {value} {value_verb} expected ({found} {found_verb} found)."
)
cardinality_validate_list_too_small = (
    "At least {value} {value_verb} expected ({found} {found_verb} found)."
)

basic_type_validate_invalid_python_type = (
    "A '{python_type}' value cannot be converted to a '{type}' instance."
)

directory_typedef_invalid_dir = "'{value}' is not a valid directory."

enum_typedef_values_required = "Values must be provided."
enum_typedef_tuple_expected = "A tuple was expected (index: {index})."
enum_typedef_string_value_required = "A string value is required (index: {index})."
enum_typedef_non_zero_required = "A non-zero value is required (index: {index})."
enum_typedef_int_or_string_expected = "An Integer or String value was expected."
enum_typedef_tuple_not_expected = "A tuple was not expected (index: {index})."
enum_typedef_invalid_value = "'{value}' is not a valid enum value."

filename_typedef_invalid_match_any = (
    "'match_any' should only be set when 'ensure_exists' is set as well."
)
filename_typedef_does_not_exist = "'{value}' is not a valid filename or directory."
filename_typedef_invalid_file = "'{value}' is not a valid filename."

integer_typedef_min_max_invalid = "{min} > {max}"
integer_typedef_too_small = "'{value}' is less than '{constraint}'."
integer_typedef_too_large = "'{value}' is greater than '{constraint}'."

number_typedef_min_max_invalid = "{min} > {max}"
number_typedef_too_small = "'{value}' is less than '{constraint}'."
number_typedef_too_large = "'{value}' is greater than '{constraint}'."

string_typedef_invalid_min_length = "{min_length} < 1"
string_typedef_invalid_max_length = "{min_length} > {max_length}"
string_typedef_too_small = "At least {value} {value_verb} expected ({found} {found_verb} found)."
string_typedef_too_large = (
    "No more than {value} {value_verb} expected ({found} {found_verb} found)."
)
string_typedef_regex_failure = (
    "The value '{value}' does not match the regular expression '{expression}'."
)

uri_typedef_invalid_value = "'{value}' is not a valid URI."

TupleTypedefNoTypes = CreateErrorType("No types were provided.")
tuple_type_item_mismatch = "{value} {value_verb} expected ({found} {found_verb} found)."

TypeOptionalToOptional = CreateErrorType("Optional types may not reference optional types.")

variant_typedef_invalid_value = textwrap.dedent(
    """\
    A '{python_type}' value does not correspond to any types within '{type}'.

        Additional Information:
            {additional_info}
    """,
)

VariantTypedefNotEnoughTypes = CreateErrorType("At least two types must be provided.")
VariantTypedefNested = CreateErrorType("Variant types may not be nested within variant types.")
